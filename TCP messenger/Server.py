from ast import Await, Tuple
from concurrent.futures import ThreadPoolExecutor, thread
import enum
from os import write
import socket
import string
import shutil
import typing
import threading
import datetime
from click import DateTime
from threading import Semaphore
import asyncio
import os

#Server side code of TCP connecter

#Probably should read these 
#https://docs.python.org/3/library/concurrent.futures.html
#https://docs.python.org/3/library/socket.html#socket.socket.listen

#Is Designed so that we can change MAX_CLIENTS without modifing any of the other code if we want additional connections
#MAX_CLIENTS is assumed in the code to always be greater then 0
MAX_CLIENTS: int = 3
BUFFER_SIZE: int = 1000 #Buffer size of the socket for data
client_list: list[tuple[socket.socket, str]] = [tuple()]*MAX_CLIENTS
HOST: str = 'localhost'
PORT: int = 1234
ADDRESS: tuple[str, int] = (HOST, PORT)
# remaining_threads: Semaphore = Semaphore(MAX_CLIENTS) #Counts the number of availible threads to deal with new connections
client_number_lock: Semaphore = Semaphore(1)
client_number: int = 1
client_history: list[list[str, DateTime]] = list() #Keeps a history of clients


#Following globals have to do with the reader writer problem (Writer's priority) (no preemption) 
#caused by keeping track of connections in threads
writer_queue_lock: Semaphore = Semaphore(1)
writer_queue: int = 0
writing: Semaphore = Semaphore(1)
available_threads: list[bool] = [True]*MAX_CLIENTS

"""
Handles the TCP connection code

@params - A tuple containing the index value of client list that holds the (conn, address) object generated by .accept

@return - None
"""
def connection_processor(
    client_value: int,
    name: str,
    client_index: int
    ) -> None:
    global writer_queue
    #print("Does it get here")
    index: int = client_value
    with client_list[index][0] as conn: #accesses the socket object created by .accept()
        conn.sendall("What is your name".encode())
        name_data: bytes = conn.recv(BUFFER_SIZE)
        client_history[client_index][0] = name_data.decode()
        name_message = "Got it your name is " + client_history[client_index][0]
        conn.sendall(name_message.encode())
        while(True):
            data: bytes = conn.recv(BUFFER_SIZE)
            if not data: #Data returns empty bytes object the client has closed the connection
                writer_queue_lock.acquire()
                writer_queue += 1
                writer_queue_lock.release()

                writing.acquire()
                available_threads[index] = True
                writing.release()

                writer_queue_lock.acquire()
                writer_queue -= 1
                writer_queue_lock.release()
                print(f"Connection terminated with {client_history[client_index][0]}")
                break
            elif (data.decode() == "status"): 
                reply_history: str = ""
                for i in client_history:
                    reply_history += i[0] + f' {i[1].now():%Y-%m-%d %H:%M:%S%z}' + "\n"
                print(reply_history)
                #needs some work
                conn.send(reply_history.encode())
            elif (data.decode() ==  'list'):
                current_dir: str = os.getcwd()
                repofolder: str = current_dir + "\\repo"
                list_of_directories = os.listdir(repofolder)
                conn.sendall(",".join(list_of_directories).encode())
                #its breaking here
                os.chdir(repofolder)
                file_name: bytes = conn.recv(BUFFER_SIZE).decode()
                if file_name in list_of_directories:
                    #Start here 
                    with open(file_name, 'rb') as f:
                        while True:
                            chunk = f.read(BUFFER_SIZE)
                            #print(chunk)
                            if not chunk:
                                break
                            print(chunk)
                            conn.sendall(chunk) 
                        conn.send(b'EOF')  
                        #End here
                else:
                    conn.sendall("That file is not in the directory".encode())

                #Set the working directory back to the normal one so next time it doesn't break
                #I know theres probably better solutions but I don't want to deal with it rn
                os.chdir(current_dir)
            else:
                print(f'Message from {client_history[client_index][0]}: {data.decode()}')
                message = data.decode() + "ACK"
                conn.sendall(message.encode())

"""
Main server function 
Accepts a connection and passes the processing off to a thread while the main function continues listening for additional connections

@param - None

@return - None
"""
def server_loop(
    s: socket.socket
    ) -> None:
    global client_number
    #The goal here is to accept requests and hand them off to other threads for processsing 
    s.listen()
    print(f"listening for connections on PORT:{PORT}")
    with ThreadPoolExecutor(max_workers = MAX_CLIENTS) as e:
        while (True):
            thread_index: int
            tcp_tuple = s.accept()
            print("Connection accepted")
            #Assign date and name for records and increase client number
            client_number_lock.acquire()
            client_name: str = f"client {client_number}"
            current_time: datetime.datetime = datetime.datetime.now()
            client_history.append([client_name, current_time])
            client_number += 1
            client_number_lock.release()
            client_index: int = len(client_history)-1
            #The semaphore is returned in the thread that handles the TCP connection and not here
            #remaining_threads.acquire() #Not needed since the threadpool caps the number of threads

            #Oh my god this is a reader writer problem
            #Writer's preference since freeing the threads is more important
            while (writer_queue != 0): pass #Move on only if there are no writers waiting
            #writing.acquire() #Prevents writers from modifing the list # I think we can just use with
            writing.acquire() #prevents writeres from modifing the list 
            thread_index = available_threads.index(True)
            #Marks that thread as unavailable this doesn't enter the queue because we already acquired the writing semaphore
            #and the fact we're here means that no one is waiting to write
            available_threads[thread_index] = False 
            client_list[thread_index] = tcp_tuple #Overwrites the data in that thread with the TCP connection data 
            #Relevant https://www.geeksforgeeks.org/python/args-kwargs-python/
            e.submit(connection_processor, thread_index, client_name, client_index) #Starts a thread with the array of the TCP values 
            writing.release()

async def main() -> None:
    #Checks if we can do ipv6 and ipv4
    if socket.has_dualstack_ipv6():
        with socket.create_server(
            ADDRESS, 
            family=socket.AF_INET6, 
            dualstack_ipv6=True
            ) as s:
            print("Socket established")
            await server_loop(s)
    else:
        #just do ivp4
        with socket.create_server(ADDRESS) as s:
            await server_loop(s)


if __name__ == "__main__":
    asyncio.run(main())